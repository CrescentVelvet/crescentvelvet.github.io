---
permalink: /game.html
layout: null
title: "飞机大战小游戏"
---
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>飞机大战小游戏</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #0a0a2a; /* 深蓝色背景 */
            touch-action: none;
            font-family: 'Arial', sans-serif;
            background-image: linear-gradient(to bottom, #0a0a2a, #000000); /* 渐变背景 */
        }
        canvas {
            border: 3px solid #4a90e2;
            border-radius: 10px;
            max-width: 100vw;
            max-height: 100vh;
            box-shadow: 0 0 20px rgba(74, 144, 226, 0.5); /* 发光效果 */
        }
        #gameInfo {
            position: fixed;
            top: 10px;
            left: 10px;
            color: #fff;
            font-size: 16px;
            font-family: 'Arial', sans-serif;
            line-height: 1.5;
            z-index: 100;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(5px);
        }
        #gameInfo div {
            margin-bottom: 5px;
        }
        #gameInfo span {
            font-weight: bold;
            color: #4a90e2;
        }
        #lastModified {
            position: fixed;
            top: 10px;
            right: 10px;
            color: #fff;
            font-size: 14px;
            font-family: 'Arial', sans-serif;
            background: rgba(0, 0, 0, 0.6);
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 100;
        }
        .game-controls {
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            padding: 10px;
            z-index: 1000;
        }
        .control-btn {
            background: rgba(74, 144, 226, 0.3);
            border: 2px solid rgba(74, 144, 226, 0.7);
            color: white;
            padding: 15px;
            border-radius: 50%; /* 圆形按钮 */
            min-width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            touch-action: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            cursor: pointer;
            transition: all 0.2s ease; /* 平滑过渡效果 */
        }
        .control-btn:active {
            background: rgba(74, 144, 226, 0.7);
            transform: scale(0.95); /* 按下时缩小效果 */
        }
        .control-text {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            text-align: center;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div id="gameInfo">
        <div>生命值: <span id="lives">3</span></div>
        <div>击杀数: <span id="kills">0</span></div>
        <div>时间: <span id="time">0</span></div>
        <div>分数: <span id="score">0</span></div>
        <div>当前帧率: <span id="fps">0</span></div>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div id="mobileControls">
        <!-- Mobile controls will be created dynamically -->
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const livesElement = document.getElementById('lives');
        const killsElement = document.getElementById('kills');
        const timeElement = document.getElementById('time');
        const scoreElement = document.getElementById('score');
        const fpsElement = document.getElementById('fps'); // 新增：获取FPS元素

        // 设置画布大小
        canvas.width = 400;
        canvas.height = 600;

        // 游戏状态
        let score = 0;
        let lives = 3;
        let kills = 0;
        let gameTime = 0;
        let gameOver = false;
        let gamePaused = false; // 添加暂停状态变量
        let startTime = Date.now();
        let pauseStartTime = 0; // 暂停开始时间
        let shootingPowerUpActive = false; // 射击特殊能力状态
        let shootingPowerUpTimeLeft = 0; // 射击特殊能力剩余时间
        let shootingPowerUpDuration = 5000; // 射击特殊能力持续5秒
        let invinciblePowerUpActive = false; // 无敌特殊能力状态
        let invinciblePowerUpTimeLeft = 0; // 无敌特殊能力剩余时间
        let invinciblePowerUpDuration = 3000; // 无敌特殊能力持续3秒
        let enemyCounter = 0; // 敌人计数器
        let lastBulletTime = 0; // 上次发射子弹的时间
        const bulletCooldown = 300; // 子弹发射冷却时间（毫秒）
        let lastFrameTime = 0; // 用于计算 deltaTime
        let fps = 0; // 新增：用于存储计算出的FPS
        let framesThisSecond = 0; // 新增：用于计算每秒的帧数
        let lastFpsUpdate = 0; // 新增：上次FPS更新的时间
        let explosions = []; // 爆炸效果数组
        let healthPowerUps = []; // 绿色方块数组（生命奖励）
        let shootingPowerUps = []; // 金色方块数组（射击奖励）
        let invinciblePowerUps = []; // 蓝色方块数组（无敌奖励）
        let healthPowerUpsTimeInterval = 23; // 每23个敌人生成一个绿色方块
        let shootingPowerUpsTimeInterval = 13; // 每13个敌人生成一个金色方块
        let invinciblePowerUpsTimeInterval = 17; // 每17个敌人生成一个蓝色方块
        let enemyMaxLevel = 100; // 最大敌机等级
        let lastEnemyTime = 0; // 上次生成敌机的时间
        let enemyInterval = 1000; // 初始敌机生成间隔（毫秒）

        // 子弹数组
        let bullets = [];
        const bulletSpeed = 7;

        // 敌机数组
        let enemies = [];
        const enemySpeed = 3;

        let stars = [];

        // 星星对象的构造函数
        function Star(x, y, size) {
            this.x = x;
            this.y = y;
            this.size = size;
            this.life = Math.random() * 5 + 3; // 3-8秒的生命周期
            this.age = 0;
            this.twinkleSpeed = Math.random() * 5 + 3; // 随机闪烁速度
            this.twinklePhase = Math.random() * Math.PI * 2; // 随机初始相位
        }

        // 绘制星星背景
        function drawStars(deltaTime) { // 确保接收 deltaTime 参数
            const starCount = 100;
            const gridX = 10;
            const gridY = 10;
            const cellWidth = canvas.width / gridX;
            const cellHeight = canvas.height / gridY;
            const starsPerCell = Math.ceil(starCount / (gridX * gridY));
            
            // 更新现有星星
            stars = stars.filter(star => {
                // star.age += 1/60; // 假设60fps
                star.age += deltaTime; // <--- 修改为这行
                if (star.age >= star.life) return false;
                
                // 计算星星的亮度
                let lifePhase = star.age / star.life;
                let twinkle = Math.sin(gameTime * star.twinkleSpeed + star.twinklePhase);
                let fadeIn = Math.min(1, star.age * 2); // 0.5秒淡入
                let fadeOut = Math.min(1, (star.life - star.age) * 2); // 0.5秒淡出
                let alpha = (0.3 + twinkle * 0.3) * fadeIn * fadeOut;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
                
                return true;
            });
            
            // 在每个网格中生成新星星
            for (let gx = 0; gx < gridX; gx++) {
                for (let gy = 0; gy < gridY; gy++) {
                    const currentStarsInCell = stars.filter(star => 
                        star.x >= gx * cellWidth && star.x < (gx + 1) * cellWidth &&
                        star.y >= gy * cellHeight && star.y < (gy + 1) * cellHeight
                    ).length;
                    
                    // 如果当前网格中的星星数量少于目标数量，添加新星星
                    if (currentStarsInCell < starsPerCell && Math.random() < 0.1) { // 10%概率生成新星星
                        const x = gx * cellWidth + Math.random() * cellWidth;
                        const y = gy * cellHeight + Math.random() * cellHeight;
                        const size = 1 + Math.random() * 2;
                        stars.push(new Star(x, y, size));
                    }
                }
            }
        }

        // 绘制星形（用于金色方块）
        function drawStar(cx, cy, radius, spikes) {
            let rot = Math.PI / 2 * 3;
            let step = Math.PI / spikes;
            
            ctx.beginPath();
            ctx.moveTo(cx, cy - radius);
            
            for (let i = 0; i < spikes; i++) {
                ctx.lineTo(
                    cx + Math.cos(rot) * radius,
                    cy + Math.sin(rot) * radius
                );
                rot += step;
                
                ctx.lineTo(
                    cx + Math.cos(rot) * radius * 0.4,
                    cy + Math.sin(rot) * radius * 0.4
                );
                rot += step;
            }
            
            ctx.lineTo(cx, cy - radius);
            ctx.closePath();
            ctx.fill();
        }

        // 绘制盾牌形状（用于无敌奖励）
        function drawShield(cx, cy, radius) {
            ctx.beginPath();
            ctx.moveTo(cx, cy - radius);
            ctx.quadraticCurveTo(
                cx + radius, cy - radius * 0.8,
                cx + radius, cy
            );
            ctx.quadraticCurveTo(
                cx + radius, cy + radius,
                cx, cy + radius
            );
            ctx.quadraticCurveTo(
                cx - radius, cy + radius,
                cx - radius, cy
            );
            ctx.quadraticCurveTo(
                cx - radius, cy - radius * 0.8,
                cx, cy - radius
            );
            ctx.closePath();
            ctx.fill();
            
            // 添加盾牌内部细节
            ctx.beginPath();
            ctx.moveTo(cx, cy - radius * 0.4);
            ctx.lineTo(cx, cy + radius * 0.4);
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(cx - radius * 0.4, cy);
            ctx.lineTo(cx + radius * 0.4, cy);
            ctx.stroke();
        }

        // 创建敌机
        function createEnemy() {
            // 每隔一段时间或达到一定条件生成敌机
            if (Date.now() - lastEnemyTime > enemyInterval) {
                lastEnemyTime = Date.now();
                
                // 根据游戏时间动态调整敌机等级，最大等级enemyMaxLevel是100级，每10秒增加1级，基础等级为1
                const level = Math.min(enemyMaxLevel, 1 + Math.floor(gameTime / 10)); 

                // 根据等级设置敌机属性
                const enemyWidth = 30 + (level - 1) * 10; // 等级越高，体积越大
                const enemyHeight = 30 + (level - 1) * 10;
                const enemySpeed = Math.max(1, 4 - (level - 1) * 0.2); // 等级越高，速度越慢，基础速度4，每升一级速度减少0.2，最小速度限制1
                
                enemies.push({
                    x: Math.random() * (canvas.width - enemyWidth),
                    y: -enemyHeight,
                    width: enemyWidth,
                    height: enemyHeight,
                    level: level, // 敌机等级
                    speed: enemySpeed, // 敌机速度
                    vx: (Math.random() - 0.5) * 2 // 随机左右速度，范围在 -1 到 1 之间
                });
                enemyCounter++; // 每创建一个敌人就计数
            }
        }

        // 更新敌机位置
        function updateEnemies(deltaTime) { // 添加 deltaTime 参数
            enemies = enemies.filter(enemy => {
                enemy.y += enemy.speed * deltaTime; // 垂直移动乘以 deltaTime
                enemy.x += enemy.vx * deltaTime; // 水平移动乘以 deltaTime

                // 左右墙壁反弹
                if (enemy.x <= 0 || enemy.x + enemy.width >= canvas.width) {
                    enemy.vx *= -1; // 反转水平方向
                }

                // // 顶部墙壁反弹 (如果需要，通常敌机不会向上反弹)
                // if (enemy.y <= -100) { // 这里设置为 -10 以确保敌机不会留在空中下不来
                //     enemy.speed *= -1; // 反转垂直方向
                // }

                return enemy.y < canvas.height; // 移除超出屏幕底部的敌机
            });
        }

        // 碰撞检测
        function checkCollisions() {

            // 辅助函数：处理敌机被击中时的逻辑
            function handleEnemyDamage(enemy) {
                // 降低敌机等级
                enemy.level--;
                
                // 更新敌机体积和速度
                enemy.width = 30 + (enemy.level - 1) * 10;
                enemy.height = 30 + (enemy.level - 1) * 10;
                enemy.speed = Math.max(-0.5, 4 - (enemy.level - 1)); // 速度上限为4，下限为-0.5，避免被子弹撞得下不来

                // 根据敌机等级计算颜色，与drawEnemy函数中的逻辑保持一致
                const hue = (enemy.level * 20) % 360; 
                const saturation = 80; 
                const lightness = 50;  
                const enemyColor = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                
                // 创建小爆炸效果
                createExplosion(
                    enemy.x + enemy.width / 2,
                    enemy.y + enemy.height / 2,
                    enemy.width,
                    enemyColor // 使用敌机颜色
                );
                
                // 如果敌机等级降为0，则移除敌机并增加分数
                if (enemy.level <= 0) {
                    // 创建大爆炸效果
                    createExplosion(
                        enemy.x + enemy.width / 2,
                        enemy.y + enemy.height / 2,
                        enemy.width * 2,
                        enemyColor // 使用敌机颜色
                    );
                    
                    // 移除被击中的敌机
                    enemies.splice(enemies.indexOf(enemy), 1); // 使用indexOf找到并移除，因为循环是倒序的

                    // 不管是不是子弹击中，都增加分数和击杀数
                    score += 100;
                    kills++;
                    scoreElement.textContent = score;
                    killsElement.textContent = kills;
                }
            }

            // 子弹击中敌机
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                let bulletHit = false;
                
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    if (bullet.x < enemy.x + enemy.width &&
                        bullet.x + bullet.width > enemy.x &&
                        bullet.y < enemy.y + enemy.height &&
                        bullet.y + bullet.height > enemy.y) {
                        
                        handleEnemyDamage(enemy); // 调用辅助函数处理敌机伤害，并标记为子弹击中
                        
                        bulletHit = true; // 标记子弹已击中敌机
                        break; // 一旦击中敌机就跳出内层循环
                    }
                }
                
                // 如果子弹击中了敌机，则移除该子弹
                if (bulletHit) {
                    bullets.splice(i, 1);
                }
            }

            // 玩家碰到绿色方块（生命奖励）
            healthPowerUps.forEach((powerUp, index) => {
                if (
                    player.x < powerUp.x + powerUp.width &&
                    player.x + player.width > powerUp.x &&
                    player.y < powerUp.y + powerUp.height &&
                    player.y + player.height > powerUp.y
                ) {
                    healthPowerUps.splice(index, 1); // 移除道具
                    if (lives < 5) { // 生命值上限为5
                        lives++;
                        livesElement.textContent = lives;
                    }
                }
            });

            // 玩家碰到金色方块（射击奖励）
            shootingPowerUps.forEach((powerUp, index) => {
                if (player.x < powerUp.x + powerUp.width &&
                    player.x + player.width > powerUp.x &&
                    player.y < powerUp.y + powerUp.height &&
                    player.y + player.height > powerUp.y) {
                    // 移除金色方块
                    shootingPowerUps.splice(index, 1);
                    // 激活特殊能力
                    shootingPowerUpActive = true;
                    shootingPowerUpTimeLeft = shootingPowerUpDuration; // 5秒特殊能力时间
                    player.speed = 8; // 提升移动速度
                }
            });

            // 玩家碰到蓝色方块（无敌奖励）
            invinciblePowerUps.forEach((powerUp, index) => {
                if (player.x < powerUp.x + powerUp.width &&
                    player.x + player.width > powerUp.x &&
                    player.y < powerUp.y + powerUp.height &&
                    player.y + player.height > powerUp.y) {
                    // 移除蓝色方块
                    invinciblePowerUps.splice(index, 1);
                    // 激活无敌特殊能力
                    invinciblePowerUpActive = true;
                    invinciblePowerUpTimeLeft = invinciblePowerUpDuration; // 3秒无敌时间
                    player.invincible = true; // 设置玩家为无敌状态
                }
            });

            // 敌机撞击玩家
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if (player.x < enemy.x + enemy.width &&
                    player.x + player.width > enemy.x &&
                    player.y < enemy.y + enemy.height &&
                    player.y + player.height > enemy.y) {
                    
                    handleEnemyDamage(enemy); // 调用辅助函数处理敌机伤害，不用传入子弹颜色
                    
                    // 只有在非无敌状态下才受到伤害
                    if (!player.invincible) {
                        lives--;
                        livesElement.textContent = lives;
                        if (lives <= 0) {
                            gameOver = true;
                        } else {
                            // 设置无敌状态
                            player.invincible = true;
                            setTimeout(() => {
                                player.invincible = false;
                            }, player.invincibleTime);
                        }
                    }
                }
            }
        }

        // 创建绿色方块（生命奖励）
        function createHealthPowerUp() {
            // 只在enemyCounter是23的倍数，且大于0时创建一个绿色方块
            if (enemyCounter % healthPowerUpsTimeInterval === 0 && enemyCounter > 0 && healthPowerUps.length === 0) {
                healthPowerUps.push({
                    x: Math.random() * (canvas.width - 20),
                    y: -20,
                    width: 20,
                    height: 20,
                    speed: 2
                });
            }
        }

        // 创建金色方块（射击奖励）
        function createShootingPowerUp() {
            // 只在enemyCounter是11的倍数，且大于0时创建一个金色方块
            if (enemyCounter % shootingPowerUpsTimeInterval === 0 && enemyCounter > 0 && shootingPowerUps.length === 0) {
                shootingPowerUps.push({
                    x: Math.random() * (canvas.width - 20),
                    y: -20,
                    width: 20,
                    height: 20,
                    speed: 2
                });
            }
        }

        // 创建蓝色方块（无敌奖励）
        function createInvinciblePowerUp() {
            // 只在enemyCounter是17的倍数，且大于0时创建一个蓝色方块
            if (enemyCounter % invinciblePowerUpsTimeInterval === 0 && enemyCounter > 0 && invinciblePowerUps.length === 0) {
                invinciblePowerUps.push({
                    x: Math.random() * (canvas.width - 20),
                    y: -20,
                    width: 20,
                    height: 20,
                    speed: 2
                });
            }
        }

        // 更新绿色方块位置
        function updateHealthPowerUps() {
            healthPowerUps = healthPowerUps.filter(powerUp => {
                powerUp.y += powerUp.speed;
                return powerUp.y < canvas.height;
            });
        }

        // 更新金色方块位置
        function updateShootingPowerUp() {
            shootingPowerUps = shootingPowerUps.filter(powerUp => {
                powerUp.y += powerUp.speed;
                return powerUp.y < canvas.height;
            });

            // 更新特殊能力时间
            if (shootingPowerUpActive) {
                shootingPowerUpTimeLeft = Math.max(0, shootingPowerUpTimeLeft - 16); // 假设60fps，约16ms每帧
                if (shootingPowerUpTimeLeft <= 0) {
                    shootingPowerUpActive = false;
                    player.speed = 5; // 恢复正常速度
                }
            }
        }

        // 更新蓝色方块位置
        function updateInvinciblePowerUps() {
            invinciblePowerUps = invinciblePowerUps.filter(powerUp => {
                powerUp.y += powerUp.speed;
                return powerUp.y < canvas.height;
            });
        
            // 更新无敌特殊能力时间
            if (invinciblePowerUpActive) {
                invinciblePowerUpTimeLeft = Math.max(0, invinciblePowerUpTimeLeft - 16); // 假设60fps，约16ms每帧
                if (invinciblePowerUpTimeLeft <= 0) {
                    invinciblePowerUpActive = false;
                    player.invincible = false; // 无敌状态结束
                }
            }
        }

        // 玩家飞机
        const player = {
            x: canvas.width / 2,
            y: canvas.height - 50,
            width: 40,
            height: 40,
            speed: 5,
            vx: 0, // Added for touch movement
            vy: 0, // Added for touch movement
            invincible: false,
            invincibleTime: 2000 // 无敌时间2秒
        };

        // 按键状态
        const keys = {
            ArrowLeft: false,
            ArrowRight: false,
            ArrowUp: false,
            ArrowDown: false,
            Space: false,
            KeyA: false,
            KeyD: false,
            KeyW: false,
            KeyS: false
        };

        // 监听键盘事件
        document.addEventListener('keydown', (e) => {
            if (e.code in keys) {
                keys[e.code] = true;
                
                // 空格键用于暂停/继续游戏
                if (e.code === 'Space' && !gameOver) {
                    gamePaused = !gamePaused;
                    
                    // 如果继续游戏，更新开始时间以避免时间跳跃
                    if (!gamePaused) {
                        const pauseDuration = Date.now() - pauseStartTime;
                        startTime += pauseDuration;
                    } else {
                        pauseStartTime = Date.now();
                    }
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code in keys) {
                keys[e.code] = false;
            }
        });

        // 更新玩家位置
        function updatePlayer(deltaTime) {
            // Keyboard controls
            if (keys.ArrowLeft) {
                player.x -= player.speed * deltaTime;
            }
            if (keys.ArrowRight) {
                player.x += player.speed * deltaTime;
            }
            if (keys.ArrowUp) {
                player.y -= player.speed * deltaTime;
            }
            if (keys.ArrowDown) {
                player.y += player.speed * deltaTime;
            }

            // Touch controls (apply velocity)
            player.x += player.vx * deltaTime; // player.vx 是由 touchmove 设置的
            player.y += player.vy * deltaTime; // player.vy 是由 touchmove 设置的

            // Clamp player position within canvas bounds
            player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
            player.y = Math.max(0, Math.min(canvas.height - player.height, player.y));
        }

        // 创建子弹
        function createBullet() {
            const currentTime = Date.now();
            // 自动发射子弹，只需检查冷却时间
            if (currentTime - lastBulletTime > bulletCooldown) {
                // 更新上次发射时间
                lastBulletTime = currentTime;
                
                // 根据特殊能力状态决定子弹颜色
                const bulletColor = shootingPowerUpActive ? '#FFD700' : '#fff';
                
                // 创建中间的子弹
                bullets.push({
                    x: player.x + player.width / 2 - 2,
                    y: player.y,
                    width: 4,
                    height: 10,
                    dx: 0, // 水平速度分量
                    color: bulletColor // 添加颜色属性
                });
        
                // 如果特殊能力激活，创建斜向子弹
                if (shootingPowerUpActive) {
                    // 左斜向子弹
                    bullets.push({
                        x: player.x + player.width / 2 - 2,
                        y: player.y,
                        width: 4,
                        height: 10,
                        dx: -2, // 向左的速度分量
                        color: bulletColor // 添加颜色属性
                    });
        
                    // 右斜向子弹
                    bullets.push({
                        x: player.x + player.width / 2 - 2,
                        y: player.y,
                        width: 4,
                        height: 10,
                        dx: 2, // 向右的速度分量
                        color: bulletColor // 添加颜色属性
                    });
                }
            }
        }

        // 更新子弹位置
        function updateBullets(deltaTime) {
            bullets = bullets.filter(bullet => {
                bullet.y -= bulletSpeed * deltaTime;
                bullet.x += (bullet.dx || 0) * deltaTime; // 添加水平移动
                // 子弹在画布范围内才保留
                return bullet.y > 0 && bullet.x > 0 && bullet.x < canvas.width;
            });
        }

        // 在draw函数中更新子弹绘制，要提前加载小爱心图片
        let heartImage = new Image();
        let heartImageLoaded = false;
        heartImage.src = 'images/heart.png'; // 请确保图像路径正确
        heartImage.onload = () => {
            heartImageLoaded = true;
        };

        // 绘制玩家飞机
        function drawPlayer() {
            // 创建玩家飞机的渐变色
            const playerGradient = ctx.createLinearGradient(
                player.x, player.y, 
                player.x, player.y + player.height
            );
            playerGradient.addColorStop(0, '#C0C0C0'); // 浅灰色
            playerGradient.addColorStop(0.5, '#A9A9A9'); // 中灰色
            playerGradient.addColorStop(1, '#808080'); // 深灰色
            
            ctx.fillStyle = playerGradient;

            // 绘制机身主体 (更锐利的歼20轮廓)
            ctx.beginPath();
            // 机头
            ctx.moveTo(player.x + player.width / 2, player.y); // 顶部尖端
            // 左侧轮廓
            ctx.lineTo(player.x + player.width * 0.4, player.y + player.height * 0.1); // 机头左侧过渡
            ctx.lineTo(player.x + player.width * 0.15, player.y + player.height * 0.25); // 左鸭翼前缘
            ctx.lineTo(player.x + player.width * 0.05, player.y + player.height * 0.35); // 左鸭翼后缘
            ctx.lineTo(player.x, player.y + player.height * 0.6); // 左主翼前缘
            ctx.lineTo(player.x + player.width * 0.1, player.y + player.height * 0.75); // 左主翼后缘
            ctx.lineTo(player.x + player.width * 0.25, player.y + player.height * 0.9); // 左机身尾部过渡
            ctx.lineTo(player.x + player.width * 0.35, player.y + player.height); // 左垂尾底部
            // 右侧轮廓
            ctx.lineTo(player.x + player.width * 0.65, player.y + player.height); // 右垂尾底部
            ctx.lineTo(player.x + player.width * 0.75, player.y + player.height * 0.9); // 右机身尾部过渡
            ctx.lineTo(player.x + player.width * 0.9, player.y + player.height * 0.75); // 右主翼后缘
            ctx.lineTo(player.x + player.width, player.y + player.height * 0.6); // 右主翼前缘
            ctx.lineTo(player.x + player.width * 0.95, player.y + player.height * 0.35); // 右鸭翼后缘
            ctx.lineTo(player.x + player.width * 0.85, player.y + player.height * 0.25); // 右鸭翼前缘
            ctx.lineTo(player.x + player.width * 0.6, player.y + player.height * 0.1); // 机头右侧过渡
            ctx.closePath();
            ctx.fill();
            
            // 添加机身和机翼的装饰线条 (模拟迷彩和结构线)
            ctx.strokeStyle = '#696969'; // 深灰色线条
            ctx.lineWidth = 1;
            ctx.beginPath();
            // 机身中线
            ctx.moveTo(player.x + player.width / 2, player.y);
            ctx.lineTo(player.x + player.width / 2, player.y + player.height * 0.95);
            // 左鸭翼线条
            ctx.moveTo(player.x + player.width * 0.15, player.y + player.height * 0.25);
            ctx.lineTo(player.x + player.width * 0.3, player.y + player.height * 0.3);
            // 右鸭翼线条
            ctx.moveTo(player.x + player.width * 0.85, player.y + player.height * 0.25);
            ctx.lineTo(player.x + player.width * 0.7, player.y + player.height * 0.3);
            // 左主翼线条
            ctx.moveTo(player.x + player.width * 0.05, player.y + player.height * 0.45);
            ctx.lineTo(player.x + player.width * 0.2, player.y + player.height * 0.6);
            // 右主翼线条
            ctx.moveTo(player.x + player.width * 0.95, player.y + player.height * 0.45);
            ctx.lineTo(player.x + player.width * 0.8, player.y + player.height * 0.6);
            // 左垂尾线条
            ctx.moveTo(player.x + player.width * 0.35, player.y + player.height);
            ctx.lineTo(player.x + player.width * 0.3, player.y + player.height * 0.85);
            // 右垂尾线条
            ctx.moveTo(player.x + player.width * 0.65, player.y + player.height);
            ctx.lineTo(player.x + player.width * 0.7, player.y + player.height * 0.85);
            ctx.stroke();

            // 绘制驾驶舱
            ctx.fillStyle = '#4682B4'; // 钢蓝色
            ctx.beginPath();
            ctx.ellipse(player.x + player.width / 2, player.y + player.height * 0.15, player.width * 0.1, player.height * 0.05, 0, 0, Math.PI * 2);
            ctx.fill();

            // 绘制引擎喷口 (两个圆形)
            ctx.fillStyle = '#36454F'; // 木炭色
            ctx.beginPath();
            ctx.arc(player.x + player.width * 0.4, player.y + player.height * 0.98, player.width * 0.05, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(player.x + player.width * 0.6, player.y + player.height * 0.98, player.width * 0.05, 0, Math.PI * 2);
            ctx.fill();
            
            // 绘制飞机引擎火焰
            const flameHeight = 10 + Math.random() * 5; // 随机火焰高度
            const flameGradient = ctx.createLinearGradient(
                player.x + player.width / 2, player.y + player.height,
                player.x + player.width / 2, player.y + player.height + flameHeight
            );
            flameGradient.addColorStop(0, '#ff9900');
            flameGradient.addColorStop(1, '#ff0000');
            
            ctx.fillStyle = flameGradient;
            ctx.beginPath();
            ctx.moveTo(player.x + player.width / 3, player.y + player.height);
            ctx.lineTo(player.x + player.width / 2, player.y + player.height + flameHeight);
            ctx.lineTo(player.x + player.width * 2/3, player.y + player.height);
            ctx.closePath();
            ctx.fill();
        }

        function draw() {
            // Background and stars are now drawn directly in gameLoop before this call

            // 绘制生命值爱心
            if (heartImageLoaded) {
                const heartSize = 25; // 爱心图像的大小
                const heartSpacing = 30; // 爱心图像之间的间隔

                for (let i = 0; i < lives; i++) {
                    ctx.drawImage(heartImage, 20 + i * heartSpacing, 20, heartSize, heartSize);
                }
            }

            // 绘制玩家（无敌状态闪烁）
            if (!player.invincible || Math.floor(Date.now() / 100) % 2) {
                drawPlayer();
            }
        
            // 绘制子弹
            bullets.forEach(bullet => {
                // 创建子弹的渐变色
                const bulletGradient = ctx.createLinearGradient(
                    bullet.x, bullet.y,
                    bullet.x, bullet.y + bullet.height
                );
                
                if (bullet.color === '#FFD700') {
                    // 金色子弹渐变
                    bulletGradient.addColorStop(0, '#FFD700');
                    bulletGradient.addColorStop(1, '#FFA500');
                } else {
                    // 普通子弹渐变
                    bulletGradient.addColorStop(0, '#ffffff');
                    bulletGradient.addColorStop(1, '#aaaaaa');
                }
                
                ctx.fillStyle = bulletGradient;
                
                // 绘制圆形子弹
                ctx.beginPath();
                ctx.ellipse(
                    bullet.x + bullet.width / 2,
                    bullet.y + bullet.height / 2,
                    bullet.width / 2,
                    bullet.height / 2,
                    0, 0, Math.PI * 2
                );
                ctx.fill();
                
                // 添加发光效果
                ctx.shadowBlur = 5;
                ctx.shadowColor = bullet.color || '#fff';
                ctx.fill();
                ctx.shadowBlur = 0; // 重置阴影
            });
        
            // 绘制敌机
            enemies.forEach(enemy => {
                // 根据敌机等级设置不同的颜色
                // 使用 HSL 颜色模型进行全色谱渐变
                // 色相 (hue) 范围 0-360
                // 20 是一个调整因子，可以改变颜色变化的“速度”
                const hue = (enemy.level * 20) % 360; 
                const saturation = 80; // 饱和度，可以调整
                const lightness = 50;  // 亮度，可以调整

                ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                
                // 绘制敌机主体（圆形）
                ctx.beginPath();
                ctx.ellipse(
                    enemy.x + enemy.width / 2,
                    enemy.y + enemy.height / 2,
                    enemy.width / 2,
                    enemy.height / 2,
                    0, 0, Math.PI * 2
                );
                ctx.fill();

                // 绘制描边 (应用于圆形)
                const strokeLightness = Math.max(0, lightness - 20); 
                ctx.strokeStyle = `hsl(${hue}, ${saturation}%, ${strokeLightness}%)`; // 敌机描边，亮度降低20
                ctx.lineWidth = 2;
                ctx.stroke(); // Apply stroke to the current path (the ellipse)

                // 绘制敌机等级数字
                ctx.fillStyle = '#000'; // 黑色文字
                // 字体大小随等级增大
                const minFontSize = 15;
                const fontSize = minFontSize + enemy.level * 2; 
                ctx.font = `${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // 添加文字描边
                ctx.strokeStyle = `hsl(${hue}, ${saturation}%, ${strokeLightness}%)`; // 敌机颜色描边，亮度与敌机描边相同
                ctx.lineWidth = 2;
                ctx.strokeText(enemy.level, enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                
                // 绘制文字本身
                ctx.fillText(enemy.level, enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
            });

            // 绘制绿色方块（生命奖励）
            healthPowerUps.forEach(powerUp => {
                // 创建绿色方块的渐变
                const healthGradient = ctx.createLinearGradient(
                    powerUp.x, powerUp.y,
                    powerUp.x + powerUp.width, powerUp.y + powerUp.height
                );
                healthGradient.addColorStop(0, '#00FF00'); // 绿色
                healthGradient.addColorStop(0.5, '#00CC00');
                healthGradient.addColorStop(1, '#00FF00');

                ctx.fillStyle = healthGradient;

                // 绘制闪烁的十字形状
                const time = Date.now() / 200;
                const scale = 0.9 + Math.sin(time) * 0.1; // 脉动效果

                ctx.save();
                ctx.translate(powerUp.x + powerUp.width / 2, powerUp.y + powerUp.height / 2);
                ctx.scale(scale, scale);

                // 绘制十字
                ctx.fillRect(-powerUp.width / 8, -powerUp.height / 2, powerUp.width / 4, powerUp.height);
                ctx.fillRect(-powerUp.width / 2, -powerUp.height / 8, powerUp.width, powerUp.height / 4);

                ctx.restore();
            });

            // 绘制金色方块（射击奖励）
            shootingPowerUps.forEach(powerUp => {
                // 创建金色方块的渐变
                const powerUpGradient = ctx.createLinearGradient(
                    powerUp.x, powerUp.y,
                    powerUp.x + powerUp.width, powerUp.y + powerUp.height
                );
                powerUpGradient.addColorStop(0, '#FFD700');
                powerUpGradient.addColorStop(0.5, '#FFC000');
                powerUpGradient.addColorStop(1, '#FFD700');
            
                ctx.fillStyle = powerUpGradient;
                
                // 绘制闪烁的星形
                const time = Date.now() / 200;
                const scale = 0.9 + Math.sin(time) * 0.1; // 脉动效果
                
                ctx.save();
                ctx.translate(powerUp.x + powerUp.width / 2, powerUp.y + powerUp.height / 2);
                ctx.scale(scale, scale);
                
                drawStar(0, 0, powerUp.width / 2, 5);
                
                ctx.restore();
            });
        
            // 绘制蓝色方块（无敌奖励）
            invinciblePowerUps.forEach(powerUp => {
                // 创建蓝色方块的渐变
                const invincibleGradient = ctx.createLinearGradient(
                    powerUp.x, powerUp.y,
                    powerUp.x + powerUp.width, powerUp.y + powerUp.height
                );
                invincibleGradient.addColorStop(0, '#00BFFF');
                invincibleGradient.addColorStop(0.5, '#0080FF');
                invincibleGradient.addColorStop(1, '#00BFFF');
            
                ctx.fillStyle = invincibleGradient;
                
                // 绘制闪烁的盾牌形状
                const time = Date.now() / 200;
                const scale = 0.9 + Math.sin(time) * 0.1; // 脉动效果
                
                ctx.save();
                ctx.translate(powerUp.x + powerUp.width / 2, powerUp.y + powerUp.height / 2);
                ctx.scale(scale, scale);
                
                drawShield(0, 0, powerUp.width / 2);
                
                ctx.restore();
            });
            
            // 绘制爆炸效果
            explosions.forEach(particle => {
                const alpha = particle.life / particle.maxLife;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        
            // 显示暂停状态
            if (gamePaused && !gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // 绘制暂停文字
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('游戏暂停', canvas.width / 2, canvas.height / 2);
                
                // 绘制继续提示
                ctx.font = '24px Arial';
                ctx.fillText('按空格键继续', canvas.width / 2, canvas.height / 2 + 40);
                
                // 绘制暂停图标
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.arc(canvas.width / 2, canvas.height / 2 - 80, 40, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.fillStyle = '#fff';
                ctx.fillRect(canvas.width / 2 - 15, canvas.height / 2 - 100, 10, 40);
                ctx.fillRect(canvas.width / 2 + 5, canvas.height / 2 - 100, 10, 40);
            }
        
            // 游戏结束
            if (gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // 绘制游戏结束文字
                ctx.fillStyle = '#ff0000';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('游戏结束', canvas.width / 2, canvas.height / 2 - 50);
                
                // 绘制得分信息
                ctx.fillStyle = '#fff';
                ctx.font = '24px Arial';
                ctx.fillText(`最终得分: ${score}`, canvas.width / 2, canvas.height / 2);
                ctx.fillText(`击杀数: ${kills}`, canvas.width / 2, canvas.height / 2 + 30);
                ctx.fillText(`游戏时间: ${gameTime}秒`, canvas.width / 2, canvas.height / 2 + 60);
                
                // 绘制重新开始提示
                ctx.fillStyle = '#4a90e2';
                ctx.fillText('按空格键重新开始', canvas.width / 2, canvas.height / 2 + 100);
            }
        }



        // 创建爆炸效果
        function createExplosion(x, y, size, color) {
            const particleCount = 20 + Math.floor(size / 5);
            
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 3;
                const radius = 1 + Math.random() * 3;
                const life = 30 + Math.random() * 20;
                
                explosions.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    radius: radius,
                    color: color,
                    life: life,
                    maxLife: life
                });
            }
        }
        
        // 更新爆炸效果
        function updateExplosions() {
            explosions = explosions.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life--;
                return particle.life > 0;
            });
        }
        
        // 游戏循环
        function gameLoop(timestamp) {
            if (!lastFrameTime) { // 第一次调用 gameLoop
                lastFrameTime = timestamp; // 初始化 lastFrameTime
                requestAnimationFrame(gameLoop); // 请求下一帧，当前帧不进行计算和绘制
                return; // 退出当前帧的处理
            }

            const deltaTime = (timestamp - lastFrameTime) / 1000; // deltaTime in seconds
            lastFrameTime = timestamp; // 更新 lastFrameTime 供下一帧使用

            // 安全校验：如果deltaTime异常，可以设置一个上限或者跳过该帧
            if (deltaTime <= 0 || deltaTime > 0.5) { // 例如，如果deltaTime为0、负数或过大（可能因为页面失焦后恢复）
                // console.warn("Abnormal deltaTime:", deltaTime, "Skipping frame or using default.");
                // deltaTime = 1/60; // 可以选择使用一个默认值，或者直接跳过更新
                requestAnimationFrame(gameLoop);
                return; // 跳过这一帧的更新和绘制，避免潜在问题
            }

            // console.log("deltaTime:", deltaTime); // 调试时可以取消注释

            if (!gamePaused) {
                if (!gameOver) { // Game logic updates only if not game over
                    gameTime += deltaTime;
                    timeElement.textContent = Math.floor(gameTime);

                    // Game logic updates
                    updatePlayer(deltaTime);
                    createBullet();
                    updateBullets(deltaTime);
                    createEnemy();
                    updateEnemies(deltaTime);
                    createHealthPowerUp();
                    createShootingPowerUp();
                    createInvinciblePowerUp();
                    updateHealthPowerUps();
                    updateShootingPowerUp();
                    updateInvinciblePowerUps();
                    updateExplosions();
                    checkCollisions();
                    // updateTime(); // Effectively removed as its logic is integrated above
                }

                // 计算FPS
                framesThisSecond++;
                if (timestamp > lastFpsUpdate + 1000) { // 每秒更新一次FPS
                    fps = framesThisSecond;
                    framesThisSecond = 0;
                    lastFpsUpdate = timestamp;
                    if (fpsElement) fpsElement.textContent = fps; // 更新FPS显示
                }
            } else if (gameOver && (keys.Space || isMobile)) { // Restart logic
                // 重置游戏
                score = 0;
                lives = 3;
                kills = 0;
                gameTime = 0;
                startTime = Date.now();
                enemyCounter = 0; // 重置敌人计数器
                scoreElement.textContent = score;
                livesElement.textContent = lives;
                killsElement.textContent = kills;
                timeElement.textContent = gameTime;
                player.x = canvas.width / 2;
                player.invincible = false;
                shootingPowerUpActive = false;
                shootingPowerUpTimeLeft = 0;
                bullets = [];
                enemies = [];
                shootingPowerUps = [];
                invinciblePowerUps = [];
                gameOver = false;
                gamePaused = false;
            }

            // 清除画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 绘制星空背景
            ctx.fillStyle = '#0a0a2a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 绘制一些随机的星星
            drawStars(deltaTime); // Pass deltaTime

            // 绘制游戏画面
            draw();

            // 继续游戏循环
            requestAnimationFrame(gameLoop);
        }

        // 开始游戏
        gameLoop();

        // 检测是否为移动设备
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // 调整画布大小
        function resizeCanvas() {
            const maxWidth = window.innerWidth - 20;
            const maxHeight = window.innerHeight - 150;
            const ratio = 400 / 600;

            let newWidth = maxWidth;
            let newHeight = maxWidth / ratio;

            if (newHeight > maxHeight) {
                newHeight = maxHeight;
                newWidth = maxHeight * ratio;
            }

            canvas.width = newWidth;
            canvas.height = newHeight;

            // 调整玩家位置
            player.x = canvas.width / 2;
            player.y = canvas.height - 50;
        }

        // 监听窗口大小变化
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // 移动设备控制
        if (isMobile) {
            const mobileControls = document.getElementById('mobileControls');
            mobileControls.innerHTML = '';
            mobileControls.className = 'game-controls';
            
            // 创建暂停按钮
            const pauseBtn = document.createElement('button');
            pauseBtn.className = 'control-btn';
            pauseBtn.id = 'pauseBtn';
            pauseBtn.innerHTML = '⏸️';
            mobileControls.appendChild(pauseBtn);
            
            let touchStartX = 0;
            let touchStartY = 0;
            
            // 触摸控制
            const handleTouchStart = (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                // 如果点击暂停按钮
                if (e.target === pauseBtn) {
                    if (!gameOver) {
                        gamePaused = !gamePaused;
                        if (!gamePaused) {
                            const pauseDuration = Date.now() - pauseStartTime;
                            startTime += pauseDuration;
                        } else {
                            pauseStartTime = Date.now();
                        }
                    }
                    return;
                }
                
                // 记录触摸起始位置
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                
                // 清除所有按键状态
                keys['ArrowLeft'] = false;
                keys['ArrowRight'] = false;
                keys['ArrowUp'] = false;
                keys['ArrowDown'] = false;
            };
            
            const handleTouchMove = (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                if (e.target === pauseBtn) return;
                
                const touchX = e.touches[0].clientX;
                const touchY = e.touches[0].clientY;
                
                // 计算触摸点移动的距离
                const deltaX = touchX - touchStartX;
                const deltaY = touchY - touchStartY;
                
                // 根据移动距离设置玩家飞机的速度 (可以调整缩放因子 1.0)
                player.vx = deltaX * 1.0; // <--- 这里的 1.0 是一个灵敏度因子
                player.vy = deltaY * 1.0; // <--- 这里的 1.0 是一个灵敏度因子
                
                // 更新触摸起始位置，以便下一次计算相对移动
                touchStartX = touchX;
                touchStartY = touchY;
            };
            
            const handleTouchEnd = () => {
                // 清除移动状态
                player.vx = 0;
                player.vy = 0;
            };
            
            // 添加触摸事件监听
            canvas.addEventListener('touchstart', handleTouchStart);
            canvas.addEventListener('touchmove', handleTouchMove);
            canvas.addEventListener('touchend', handleTouchEnd);
            canvas.addEventListener('touchcancel', handleTouchEnd);            
            pauseBtn.addEventListener('touchstart', handleTouchStart);
            
            // 隐藏移动端双击缩放
            document.documentElement.addEventListener('touchstart', (e) => {
                if (e.touches.length > 1) {
                    e.preventDefault();
                }
            }, { passive: false });

            // 禁止页面滚动
            document.body.addEventListener('touchmove', (e) => {
                e.preventDefault();
            }, { passive: false });
        } else {
            // 在非移动设备上隐藏控制按钮
            document.getElementById('mobileControls').style.display = 'none';
        }
    </script>
</body>
</html>

<style>
    #lastModified {
        position: fixed;
        top: 10px;
        right: 10px;
        color: #fff;
        font-size: 14px;
        font-family: Arial, sans-serif;
        background: rgba(0, 0, 0, 0.5);
        padding: 5px 10px;
        border-radius: 5px;
        z-index: 100;
    }
</style>

<!-- 在 gameInfo div 后添加 -->
<div id="lastModified"></div>

<script>
// 在游戏循环开始前添加
const lastModifiedElement = document.getElementById('lastModified');

// 获取并显示最后修改时间
fetch(window.location.href)
    .then(response => {
        const lastModified = response.headers.get('last-modified');
        if (lastModified) {
            const date = new Date(lastModified);
            const formattedDate = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
            const formattedTime = `${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
            lastModifiedElement.textContent = `最后更新: ${formattedDate} ${formattedTime}`;
        } else {
            lastModifiedElement.textContent = '最后更新时间未知';
        }
    })
    .catch(() => {
        lastModifiedElement.textContent = '最后更新时间未知';
    });
</script>
